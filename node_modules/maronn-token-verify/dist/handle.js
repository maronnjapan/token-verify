"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleToken = void 0;
const decode_1 = require("./decode");
const token_1 = require("./token");
const signature_1 = require("./signature");
const jws_1 = __importDefault(require("jws"));
function handleToken(token, key, audiences, exp, options) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
        if (options.clockTimestamp && typeof options.clockTimestamp !== 'number') {
        }
        if (options.nonce !== undefined && (typeof options.nonce !== 'string' || options.nonce.trim() === '')) {
        }
        const clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1000);
        if (!token) {
            throw new Error('Token is required');
        }
        const isJws = (0, token_1.isJwsSignature)(token);
        if (!isJws) {
            throw new Error('Token must be a JWS signature');
        }
        const decodedToken = (0, decode_1.decode)(token);
        if (!decodedToken) {
            throw new Error('Token is invalid');
        }
        const header = decodedToken.header;
        let getSecret = key;
        const jwksKey = yield (0, signature_1.getVerifyKeyFromJwks)(key, header.kid);
        if (jwksKey.length > 0) {
            getSecret = jwksKey;
        }
        const keyObject = yield (0, signature_1.getKeyObject)(getSecret);
        if (!keyObject) {
            throw new Error('Invalid key');
        }
        const algorithms = (0, signature_1.setAlgorithm)(keyObject);
        if (!(0, signature_1.checkAlgorithm)(algorithms, header.alg, keyObject)) {
            throw new Error('Invalid algorithm');
        }
        const valid = jws_1.default.verify(token, header.alg, getSecret);
        if (!valid) {
            throw new Error('Invalid signature');
        }
        const payload = decodedToken.payload;
        const notBefore = (0, token_1.isNotBefore)(clockTimestamp, (_a = options.clockTolerance) !== null && _a !== void 0 ? _a : 0, payload.nbf, options.checkNotBefore);
        if (!notBefore) {
            throw new Error('Token not active');
        }
        const notExpired = (0, token_1.isNotExpired)(clockTimestamp, (_b = options.clockTolerance) !== null && _b !== void 0 ? _b : 0, payload.exp, options.ignoreExpiration);
        if (!notExpired) {
            throw new Error('Token expired');
        }
        const isMatchAudience = (0, token_1.matchAudience)(audiences, payload.aud, options.ignoreAudience);
        if (!isMatchAudience) {
            throw new Error('Invalid audience');
        }
        const isMatchIssuer = (0, token_1.matchIssuer)(options.issuer, payload.iss);
        if (!isMatchIssuer) {
            throw new Error('Invalid issuer');
        }
        const isMatchSubject = (0, token_1.matchSubject)(options.subject, payload.sub);
        if (!isMatchSubject) {
            throw new Error('Invalid subject');
        }
        const isMatchJwtId = (0, token_1.matchJwtId)(options.nonce, payload.jti);
        if (!isMatchJwtId) {
            throw new Error('Invalid jwt id');
        }
        return decodedToken.payload;
    });
}
exports.handleToken = handleToken;
//# sourceMappingURL=handle.js.map